title: 编译原理 LR分析法
categories: [编译原理]
tags: [编译原理,语法分析,LR分析法,LR(0)分析,活前缀,SLR(1)分析,LR(1)分析法,LALR(1)分析法]
date: 2016-05-12 11:16:06
---
## 一、LR分析器

一个LR分析器由3部分组成：
（1）总控程序，也可以称为驱动程序。对所有的LR分析器总控程序都是相同的。
（2）分析表或分析函数，不同的文法分析表将不同，同一个文法采用的LR分析器不用时，分析表将也不同，分析表又可分为动作表（ACTION）和状态转换（GOTO）表两个部分，他们都可以用二维数组表示。
（3）分析栈，包括文法符号栈和相应的状态栈，它们均是先进后出栈。
分析器的动作就是由栈顶状态和当前输入符号所决定（LR（0）分析器不需向前查看输入符号）
![](/img/Compilers/69.jpg)
SP为栈指针，S[i]为状态栈，X[i]为文法符号栈。状态转换表用GOTO[$S_i$,X]=$S_j$表示，规定当栈顶状态为$S_i$遇到当前文法符号为X时应转向状态$S_j$，X为终结符或非终结符。
ACTION[$S_i$,a]规定栈顶状态为$S_i$时遇到输入符号a应执行的动作。

<!--more-->

动作有四种可能
（1）移进：
把$S_j$=GOTO[$S_i$,a]移入到状态栈，把a移入到文法符号栈，其中i，j表示状态号。
（2）归约：
当在栈顶形成句柄为$\beta$时，则用$\beta$归约为相应的非终结符A，即文法中有A$\rightarrow$B的产生式，若$\beta$的长度为r（即|$\beta$|=r），则从状态栈和文法符号栈中自栈顶向下去掉r个符号，即栈指针SP减去r，并把A移入文法符号栈内，$S_j$=GOTO[$S_i$,A]移入状态栈，其中$S_i$为修改指针后的栈顶状态。
（3）接受acc：
当归约到文法符号栈只剩下文法的开始符号S'时，并且输入符号串即当前输入符石'#'，则为分析成功。
（4）报错：
当遇到状态栈顶为某一状态下出现不该遇到的文法符号时，则报错，说明输入串不是该文法能接受的句子。

## 二、LR（0）分析

2.1 活前缀

![](/img/Compilers/70.jpg)
![](/img/Compilers/71.jpg)
![](/img/Compilers/72.jpg)
![](/img/Compilers/73.jpg)

2.2 活前缀及其可归约前缀的一般计算方法

![](/img/Compilers/74.jpg)
这里$\alpha$表明了在规范推导中在非终结符A左部所出现的符号串的集合。有了集合$\alpha$就可以找出不包括句柄在内的所有活前缀。

若文法G中有产生式B$\rightarrow\gamma$A$\delta$,则有
LC(A)$\supseteq$LC(B) $\cdot$ {$\gamma$}
因为在规范推导中有
![](/img/Compilers/75.jpg)
而由定义知：
$\alpha\in$LC(B)
$\alpha\gamma\in$LC(A)
根据定义
![](/img/Compilers/76.jpg)

2.3 LR(0)项目集规范族的构造

（1）LR(0)项目
在文法G中每个产生式的右部适当的位置添加一个圆点构成项目。
A$\rightarrow\epsilon$仅有A$\rightarrow\cdot$
（2）构造识别活前缀的NFA
如果把文法的所有产生式的项目都引出，每个项目都为NFA的一个状态。
状态直接的转换关系确定方法为：
![](/img/Compilers/77.jpg)
![](/img/Compilers/78.jpg)
![](/img/Compilers/79.jpg)
（3）LR(0)项目集规范族的构造
![](/img/Compilers/80.jpg)
![](/img/Compilers/81.jpg)
![](/img/Compilers/82.jpg)
![](/img/Compilers/83.jpg)
![](/img/Compilers/84.jpg)
定义转向GO(I,X)函数
![](/img/Compilers/85.jpg)

使用闭包函数（CLOSURE）和转向函数（GO(I,X)）构造文法G'的LR（0）项目集规范族，步骤如下：
a)置项目S'$\rightarrow\cdot$ S为初态的核，然后对核求闭包，CLOSURE（{S'$\rightarrow\cdot$S}）得到初态的项目集
b)对初态集或其它所构造的项目集应用转换函数GO(I,X)=CLOSURE(J)求出新状态J的项目集。
c)重复b）直到不出现新的项目集为止。


进一步分析所构造的LR(0)项目集规范族的项目类型有：
a)移进项目
圆点后为终结符的项目，形如![](/img/Compilers/86.jpg)，相应状态为移进状态。
b)归约项目
圆点在产生式右部最后的项目，形如![](/img/Compilers/87.jpg)，对于$\beta$=$\epsilon$的项目为A$\rightarrow\cdot$，相应状态为归约状态。
c)待约项目
圆点后为非终结符的项目形如![](/img/Compilers/88.jpg)，这表明用产生式A的右部归约时，首先要将B的产生式右部归约为B，对A的右部才能继续进行分析，就就是期待着继续分析过程中首先能进行归约得到B。
d)接受项目
当归约项目为S'$\rightarrow$S$\cdot$时，则表明已分析成功，即输入串为该文法的句子，相应状态为接受状态。

一个项目中可能包含以上四种不同的项目，但是一个项目集中不能有下列情况存在：
a)移进和归约项目同时存在。（移进-归约冲突）
b)归约和归约项目同时存在。（归约-归约冲突）

一个文法的LR(0)项目集规范族不存在移进-归约，或归约-归约冲突时，称这个文法为**LR(0)文法**。

（4）LR(0)分析表的构造

LR(0)分析表可以用一个二维数组表示，行标为状态号，列标为文法符号和'#'号，分析表的内容可由两部分组成，一部分为动作（ACTION）表，它表示当前状态下所面临输入符应作的动作是移进、归约、接受或出错，动作表的标识只包含终结符和'#'，另一部分为转换表（GOTO），它表示在当前状态下面临文法符号时应转向的下一个状态，相当于识别活前缀的有限自动机DFA的状态转换矩阵。

LR(0)分析表的构造算法
![](/img/Compilers/89.jpg)
![](/img/Compilers/90.jpg)

（5）LR(0)分析器的工作过程
对一个文法构造了它的LR（0）分析表后就可以在LR分析器的总控程序（驱动程序）控制下对输入串进行分析，即根据输入串的当前符号和分析栈的栈顶状态查找分析表应采取的动作，对状态栈和符号栈进行相应的操作即移进、归约、接受或报错。

a）若ACTION[S,a]=$S_i$，a为终结符，则把a移入符号栈，j移入状态栈。
b）若ACTION[S,a]=$r_j$，a为终结符或#号，则用第j个产生式归约，并将两个栈的指针减去k，其中k为第j个产生式右部的符号串长度，这时当前面临符号为第j个产生式左部的非终结符。
c）若ACTION[S,a]=acc，a应为#号，则为接受，表示分析成功。
d）若GOTO[S,A]=j,A为非终结符，表明前一动作是用关于A的产生式归约的，当前面临非终结符A应移入符号栈，j移入状态栈。对于终结符的GOTO[S,a]已和ACTION[S,a]重合。
e）若ACTION[S,a]=空白，则转向出错处理。


## 三、SLR(1)分析法

假定一个LR(0)规范族中含有如下的项目集（状态）I
![](/img/Compilers/91.jpg)
也就是在该项目集中含有移进-归约冲突和归约-归约冲突，那么只要在所有含有A或B的句型中，直接跟在A或B后的可能终结符的集合即FOLLOW(A)和FOLLOW(B)互不相交，且都不包含b，也就是只要满足
![](/img/Compilers/92.jpg)
那么，当在状态I时面临某输入符号位a时，则动作可由下规定决策。
a)若a=b，则移进。
b)若a$\in$FOLLOW(A)，则用产生式A$\rightarrow\gamma$
c)若a$\in$FOLLOW(B)，则用产生式B$\rightarrow\delta$
d)此外，报错。
![](/img/Compilers/93.jpg)
如果对于一个文法的LR（0）项目集规范族的某些项目集或LR（0）分析表中所含有的动作冲突都能用上诉方法解决，则称这个文法是SLR(1)文法，所构造的分析表为SLR（1）分析表，使用SLR（1）分析表的分析器称为SLR（1）分析器。

SLR（1）分析表的构造步骤：
![](/img/Compilers/94.jpg)

## 四、LR(1)分析法

4.1 LR(1)项目集族的构造

![](/img/Compilers/95.jpg)

4.2 LR(1)分析表的构造

![](/img/Compilers/96.jpg)

## 五、LALR（1）分析

同心集是指心相同的项目集合并在一起，因此同心集合并后心仍相同，只是超前搜索符集合为各同心集超前搜索符集合的和集。

LALR（1）分析表的构造
![](/img/Compilers/97.jpg)
![](/img/Compilers/98.jpg)
